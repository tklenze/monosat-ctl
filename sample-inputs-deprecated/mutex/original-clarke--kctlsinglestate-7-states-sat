c     <#Vars> <#Clauses>
p cnf 1000     1
1000 0
c kctlsinglestate <KripkeID> <#Nodes> <#Processes> <States/Process> <selfloops> <ctlvar> <CTL formula>"
kctlsinglestate   0          7        2            3                0           1000     (NCS1 AND NCS2)
c
c 2.
AND AG NOT (CS1 AND CS2)
c
c 3.
AND AG (NOT TRY1 OR AF CS1)
AND AG (NOT TRY2 OR AF CS2)
c
c 4.
cAND AG (NCS1 OR (TRY1 OR CS1))
cAND AG (NCS2 OR (TRY2 OR CS2))
cAND AG (NOT NCS1 OR NOT (TRY1 OR CS1))
cAND AG (NOT NCS2 OR NOT (TRY2 OR CS2))
cAND AG (NOT TRY1 OR NOT (NCS1 OR CS1))
cAND AG (NOT TRY2 OR NOT (NCS2 OR CS2))
cAND AG (NOT CS1 OR NOT (NCS1 OR TRY1))
cAND AG (NOT CS2 OR NOT (NCS2 OR TRY2))
c
c 5. this is where it gets interesting. We say that either EX TRY1 must hold, <s>or the first process remains in the same state and will eventually reach TRY1</s>.
AND AG (NOT NCS1 OR EX TRY1)
AND AG (NOT NCS2 OR EX TRY2)
c
c 6. we ommit EXi True, since that is guaranteed in 9. for the product automaton. Basically this is similar to 5., but we do not require that eventually CSi is reached
AND AG (NOT TRY1 OR AX (CS1 OR TRY1))
AND AG (NOT TRY2 OR AX (CS2 OR TRY2))
c
c 7. Similar to 5.
AND AG (NOT CS1 OR EX NCS1)
AND AG (NOT CS2 OR EX NCS2)
c
c 8. if process one moves, process two does nothing
c
c# it could also work a different way, in which way we could disable self loops if we had any:
c# AG [[NCS1 AND NCS2] -> AX [[NCS1 AND NOT NCS2] OR [NOT NCS1 AND NCS2]]]
c# this would basically disable all self loops
c
ctesting:
AND AG (NOT (NCS1 AND NCS2) OR AX (NCS1 OR NCS2))
AND AG (NOT (NCS1 AND TRY2) OR AX (NCS1 OR TRY2))
AND AG (NOT (NCS1 AND CS2) OR AX (NCS1 OR CS2))
c
AND AG (NOT (TRY1 AND NCS2) OR AX (TRY1 OR NCS2))
AND AG (NOT (TRY1 AND TRY2) OR AX (TRY1 OR TRY2))
AND AG (NOT (TRY1 AND CS2) OR AX (TRY1 OR CS2))
c
AND AG (NOT (CS1 AND NCS2) OR AX (CS1 OR NCS2))
AND AG (NOT (CS1 AND TRY2) OR AX (CS1 OR TRY2))
AND AG (NOT (CS1 AND CS2) OR AX (CS1 OR CS2))
c
c 9. There is always a next state. We don't need that, since it is implicitly added to the formula
c AG (EX 0 OR EX NOT 0)
c
c
c
c We need the conditions that under transition, _one_ of the two components have to change, i.e. that there are no self loop. c We would need to do that for all 9 combinations. However, we don't need to do this if there are a minimum number of states in the cross product and we don't allow self loops in the Kripke structure, by simply not adding reflexive kedges.
c
c
c extra conditions: we don't want states to "jump", i.e. to go from NCS to CS without visiting TRY first
c
c
c Extra condition that Clarke didn't think of apparently: 
c
c important! System can move when one process does not want the Mutex
cAND AG (NOT NCS1 OR EX NCS1)
cAND AG (NOT NCS2 OR EX NCS2)
c
c don't go directly from NCS to CS, go via TRY.
cAND AG (NCS1 -> AX NOT CS1)
cAND AG (NCS2 -> AX NOT CS2)
c
c don't go directly from CS to TRY, go via NCS.
cAND AG (CS1 -> AX NOT TRY1)
cAND AG (CS2 -> AX NOT TRY2)


