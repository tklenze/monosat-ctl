c Philosopher's state is implicit by the state of the forks left and right
c
c Every fork is in exactly on of three states:
c left - it belongs to the philosopher to the left
c right - it belongs to the philosopher to the right
c table - it does not belong to any philosopher
c
c     <#Vars> <#Clauses>
p cnf 1000     1
1000 0
c kctlsimp <KripkeID> <#Nodes> <#APs> <selfloops> <ctlvar> <CTL formula>"
kctlsimp   0          6        20     0           1000      table0
AND table1
AND table2
AND table3
AND table4
c
c Encoding the fork state: it is exactly on of {left, right, table}
AND AG (left0 OR (right0 OR table0))
AND AG (left0 -> NOT (right0 OR table0))
AND AG (right0 -> NOT (left0 OR table0))
AND AG (table0 -> NOT (left0 OR right0))
AND AG (left1 OR (right1 OR table1))
AND AG (left1 -> NOT (right1 OR table1))
AND AG (right1 -> NOT (left1 OR table1))
AND AG (table1 -> NOT (left1 OR right1))
AND AG (left2 OR (right2 OR table2))
AND AG (left2 -> NOT (right2 OR table2))
AND AG (right2 -> NOT (left2 OR table2))
AND AG (table2 -> NOT (left2 OR right2))
AND AG (left3 OR (right3 OR table3))
AND AG (left3 -> NOT (right3 OR table3))
AND AG (right3 -> NOT (left3 OR table3))
AND AG (table3 -> NOT (left3 OR right3))
AND AG (left4 OR (right4 OR table4))
AND AG (left4 -> NOT (right4 OR table4))
AND AG (right4 -> NOT (left4 OR table4))
AND AG (table4 -> NOT (left4 OR right4))
c
c Absence of starvation
cc commmented out, because there is a path in which a philosopher is always hungry
cAND AG AF (right0 AND left1)
cAND AG AF (right1 AND left2)
cAND AG AF (right2 AND left3)
cAND AG AF (right3 AND left4)
cAND AG AF (right4 AND left0)
c
c Forks have to be exchanged via table
AND AG (right0 -> AX (table0 OR right0))
AND AG (right1 -> AX (table1 OR right1))
AND AG (right2 -> AX (table2 OR right2))
AND AG (right3 -> AX (table3 OR right3))
AND AG (right4 -> AX (table4 OR right4))
AND AG (left0 -> AX (table0 OR left0))
AND AG (left1 -> AX (table1 OR left1))
AND AG (left2 -> AX (table2 OR left2))
AND AG (left3 -> AX (table3 OR left3))
AND AG (left4 -> AX (table4 OR left4))
c
c If a philosopher is not hungry, then he can remain non-hungry or he can become hungry
AND AG (NOT hungry0 -> (EX hungry0 AND EX NOT hungry0))
AND AG (NOT hungry1 -> (EX hungry1 AND EX NOT hungry1))
AND AG (NOT hungry2 -> (EX hungry2 AND EX NOT hungry2))
AND AG (NOT hungry3 -> (EX hungry3 AND EX NOT hungry3))
AND AG (NOT hungry4 -> (EX hungry4 AND EX NOT hungry4))
c
c If a philosopher is hungry, then he is hungry until he eats, and then he is not hungry
AND AG (hungry0 -> (hungry0 AU ((right0 AND left1) AND NOT hungry0)))
AND AG (hungry1 -> (hungry1 AU ((right1 AND left2) AND NOT hungry1)))
AND AG (hungry2 -> (hungry2 AU ((right2 AND left3) AND NOT hungry2)))
AND AG (hungry3 -> (hungry3 AU ((right3 AND left4) AND NOT hungry3)))
AND AG (hungry4 -> (hungry4 AU ((right4 AND left0) AND NOT hungry4)))


