c This example is due to E.A. Emerson and R. Samanta and their 2011 paper "An Algorithmic Framework for Synthesis of Concurrent Programs"
c
c Process 1: Reader
c Process 2: Writer (gets priority access on Mutex)
c
c     <#Vars> <#Clauses>
p cnf 105     1
105 0
c kctlsimp <KripkeID> <#Nodes> <#APs> <selfloops> <ctlvar> <CTL formula>"
kctlsimp   0          8        6      0           105      (NCS1 AND NCS2)
c 
c 1. Priority of writer over reader for outstanding requests to enter the critical region:
AND AG((TRY1 AND TRY2 ) -> (TRY1 AU CS2)).
c 
c 2. Mutex property
AND AG NOT (CS1 AND CS2)
c 
c 3a. Absence of starvation for reader (Process 1), provided that the writer leaves the critical section.
AND AG (TRY1 -> AF (CS1 OR NOT NCS2))
c 3b. Absence of starvation for writer (Process 2).
AND AG (TRY2 -> AF CS2)
c 
c 4. Encoding that each process is in exactly one of NCS, TRY and CS.
AND AG (NCS1 OR (TRY1 OR CS1))
AND AG (NCS2 OR (TRY2 OR CS2))
AND AG (NOT NCS1 OR NOT (TRY1 OR CS1))
AND AG (NOT NCS2 OR NOT (TRY2 OR CS2))
AND AG (NOT TRY1 OR NOT (NCS1 OR CS1))
AND AG (NOT TRY2 OR NOT (NCS2 OR CS2))
AND AG (NOT CS1 OR NOT (NCS1 OR TRY1))
AND AG (NOT CS2 OR NOT (NCS2 OR TRY2))
c 
c 5. If you are in the NCS, you can enter the TRY section.
AND AG (NOT NCS1 OR EX TRY1)
AND AG (NOT NCS2 OR EX TRY2)
c 
c 6. we ommit EXi True, since that is guaranteed in 9. for the product automaton. Basically this is similar to 5., but we do not require that eventually CSi is reached
AND AG (NOT TRY1 OR AX (CS1 OR TRY1))
AND AG (NOT TRY2 OR AX (CS2 OR TRY2))
c 
c 7. Similar to 5.
AND AG (NOT CS1 OR EX NCS1)
AND AG (NOT CS2 OR EX NCS2)
c 
c 8. if process one moves, process two does nothing
c # it could also work a different way, in which way we could disable self loops if we had any:
c # AG [[NCS1 AND NCS2] -> AX [[NCS1 AND NOT NCS2] OR [NOT NCS1 AND NCS2]]]
c # this would basically disable all self loops
c testing:
AND AG (NOT (NCS1 AND NCS2) OR AX (NCS1 OR NCS2))
AND AG (NOT (NCS1 AND TRY2) OR AX (NCS1 OR TRY2))
AND AG (NOT (NCS1 AND CS2) OR AX (NCS1 OR CS2))
c 
AND AG (NOT (TRY1 AND NCS2) OR AX (TRY1 OR NCS2))
AND AG (NOT (TRY1 AND TRY2) OR AX (TRY1 OR TRY2))
AND AG (NOT (TRY1 AND CS2) OR AX (TRY1 OR CS2))
c
AND AG (NOT (CS1 AND NCS2) OR AX (CS1 OR NCS2))
AND AG (NOT (CS1 AND TRY2) OR AX (CS1 OR TRY2))
AND AG (NOT (CS1 AND CS2) OR AX (CS1 OR CS2))
c 
c 9. There's always a successor. We don't need to add this, since it is implicitly added to the formula my MonoSAT-CTL
c AND AG (EX 0 OR EX NOT 0)
c 
c We need the conditions that under transition, _one_ of the two components have to change, i.e. that there are no self loop. We would need to do that for all 9 combinations. However, we don't need to do this if there are a minimum number of states in the cross product and we don't allow self loops in the Kripke structure, by simply not adding reflexive kedges.
c Extra condition that Clarke didn't think of apparently: 
c important! System can move when one process does not want the Mutex
AND AG (NOT NCS1 OR EX NCS1)
AND AG (NOT NCS2 OR EX NCS2)
c extra conditions: we don't want states to "jump", i.e. to go from NCS to CS without visiting TRY first
c don't go directly from NCS to CS, go via TRY.
AND AG (NCS1 -> AX NOT CS1)
AND AG (NCS2 -> AX NOT CS2)
c don't go directly from CS to TRY, go via NCS.
AND AG (CS1 -> AX NOT TRY1)
AND AG (CS2 -> AX NOT TRY2)

